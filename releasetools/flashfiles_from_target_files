#!/usr/bin/env python
#
# Copyright (C) 2008 The Android Open Source Project
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
Usage: flashfiles_from_target_files [options] <input_target_files_zip> <output_file>

  -U  (--unified-variants)
      Toggle ON mega (all variants) flash files from target file.

  -V  (--variant) <variant_name>
      Generate a single variant-specific flash files from target file.

"""

import sys
import os
import re
import tempfile
import zipfile
import shutil
import iniparser
import flash_cmd_generator
import flashxml
import flashflsxml
import json

# Sources:
# fastboot - build a Fastboot boot image
# boot:xxxx - build an AOSP boot image xxxx (either "boot" or "recovery")
# provdatazip: Pull a named file out of RADIO/flashfiles.zip
# images - pull a named file out of tfp IMAGES/
# bootloader - Build a bootloader image
# bootloaderzip - Pull a named file out of RADIO/bootloader.zip

# Import Android Release Tools
sys.path.append("build/tools/releasetools")
import common

sys.path.append("device/intel/build/releasetools")
import intel_common

OPTIONS = common.OPTIONS
OPTIONS.variants = None
OPTIONS.unified_variants = False

flashfile_content = []
variant_files = ["bootloader", "btsdata.ini", "firmware.bin", "oem.img"]

class VariantIpGenerator:
    def __init__(self, ip, configs, variants, variant_files):
        # Original iniparser object
        self.ip = ip
        # Variant version of iniparser object
        self.variant_ip = ip
        # List of variants
        self.variants = variants
        # List of variant-specific files
        self.variant_files = variant_files
        # List of output "sections" to cycle through
        self.output_sections = []
        for c in configs:
            self.output_sections.append('output.' + c[0])

        # Remove variant 'additional-files' from list to avoid Phone Flash Tool issues
        if ip.has_option('global', 'additional-files'):
            exclude_files = ip.get('global', 'additional-files').split()
            for variant_item in variant_files:
                for exclude_item in exclude_files:
                    if variant_item in exclude_item:
                        self.variant_files.remove(variant_item)

    def generate_variant_ip(self):
        # Add variant files to ip
        self.__add_variant_files()
        # Cycle through output "sections"
        for section in self.output_sections:
            config_list = []
            # Add variant configs for each configuration "section"
            for config in self.ip.get(section, 'configurations').split():
                config_list.extend(self.__add_variant_configs(config))
            # Modify output "section" to use new variant configs instead of original "generics"
            self.variant_ip.sec[section]['configurations'] = ' '.join(config_list)

    def __add_variant_files(self):
        for item in self.variant_files:
            self.variant_ip.new_section('[file.{}]'.format(item))
            for variant in self.variants:
                item_name, item_extension = os.path.splitext(item)
                self.variant_ip.append_option(variant, item_name + "_" + variant + item_extension)

    def __add_variant_configs(self, config):
        variant_configs = []
        section = 'configuration.' + config
        to_copy = ['startState', 'sets', 'brief', 'description']
        for variant in self.variants:
            variant_configs.append('{}_{}'.format(config, variant))
            self.variant_ip.new_section('[configuration.{}]'.format(variant_configs[-1]))
            config_dict = self.ip.copy_option(section, to_copy)
            config_dict['name'] = 'configuration.{}'.format(variant_configs[-1])
            for key in config_dict.keys():
                self.variant_ip.append_option(key, config_dict[key])
            for item in self.variant_files:
                self.variant_ip.append_option('parameters',
                                              '{}:{}'.format(os.path.splitext(item)[0], variant))
        return variant_configs

def getBuildProp(unpack_dir, prop):
    with open(os.path.join(unpack_dir, "SYSTEM", "build.prop"), "r") as fp:
        for line in fp.readlines():
            if line.startswith(prop):
                return line.split("=")[1].strip()
    raise Exception("property not found in build.prop: " + prop)

def getFromZip(zip_path, filename):
    with zipfile.ZipFile(zip_path, "r") as zf:
        data = zf.open(filename).read()
    return common.File(filename, data)

def getProvdataVariants(unpack_dir):
    variants = []
    working_path = os.path.join(unpack_dir, "RADIO")
    # Use regex analysis of provdata files to determine current variants
    regex = re.compile('provdata_(?P<variant>\w+).zip')
    for f in os.listdir(working_path):
        m = regex.match(os.path.basename(f))
        if m and m.group('variant'):
            variants.append(m.group('variant'))
    return variants

def process_image(unpack_dir, dest_zip, source, target, variant=None):
    # Determine naming for target being inserted into zipfile
    if OPTIONS.unified_variants and variant and target in variant_files:
        target_name, target_extension = os.path.splitext(target)
        target_out = target_name + "_" + variant + target_extension
    else:
        target_out = target
    # Determine if target is already inserted into zipfile
    if target_out in flashfile_content:
        return
    else:
        print "-- Adding", target_out
    # Retrieve file from target file package based on source & target strings
    if source == "fastboot":
        ifile = intel_common.GetFastbootImage(unpack_dir)
    elif source == "bootloader":
        bdata = intel_common.GetBootloaderImageFromTFP(unpack_dir, variant=variant)
        ifile = common.File(target, bdata)
    elif source == "images":
        ifile = common.File.FromLocalFile(target, os.path.join(unpack_dir, "IMAGES", target))
    elif source == "fls_images":                                                  
        intel_common.build_fls(unpack_dir, target, variant=variant)               
        ifile = common.File.FromLocalFile(target, os.path.join(unpack_dir, "IMAGES", target))
    elif source == "provdatazip":
        suffix = "_" + variant if variant else ""
        ifile = getFromZip(os.path.join(unpack_dir, "RADIO", "provdata%s.zip" % suffix), target)
    elif source == "bootloaderzip":
        ifile = getFromZip(os.path.join(unpack_dir, "RADIO", "bootloader.zip"), target)
    elif source.startswith("boot:"):
        _, iname = source.split(":")
        ifile = common.GetBootableImage(target, iname+".img", unpack_dir, iname.upper())
    elif source == "radio":
        ifile = common.File.FromLocalFile(target, os.path.join(unpack_dir, "RADIO", target))
    else:
        raise Exception("unknown source image type " + source)
    # Add file to zip, using target_out for naming.  According to the
    # documentation the File.AddToZip() interface is not suitable for
    # file larger than 2GiB and common.ZipWrite() must be used
    # instead.
    if ifile.size >= (1 << 31):
        tmpfile = ifile.WriteToTemp()
        common.ZipWrite(dest_zip, tmpfile.name, target_out)
    else:
        ifile.name = target_out
        ifile.AddToZip(dest_zip)
    flashfile_content.append(target_out)

def main(argv):
    def option_handler(o, a):
        if o in ("-V", "--variant"):
            OPTIONS.variants = [a]
        elif o in ("-U", "--unified-variants"):
            OPTIONS.unified_variants = True
        else:
            return False
        return True

    args = common.ParseOptions(argv, __doc__,
            extra_opts = "V:U",
            extra_long_opts = ["variant=","unified-variants"],
            extra_option_handler = option_handler)
    if len(args) < 2 or (OPTIONS.variants and OPTIONS.unified_variants):
        common.Usage(__doc__)
        sys.exit(1)

    print "Unzipping target-files..."
    unpack_dir, input_zip = common.UnzipTemp(args[0])
    OPTIONS.info_dict = common.LoadInfoDict(input_zip)
    if OPTIONS.unified_variants:
        OPTIONS.variants = getProvdataVariants(unpack_dir)

    build_type = getBuildProp(unpack_dir, "ro.build.type")
    platform = getBuildProp(unpack_dir, "ro.product.name")

    # Retrieve "generic" PFT instructions from target file package
    flashfile = os.path.join(unpack_dir, "RADIO", "flashfiles")
    if os.path.isfile(flashfile + ".ini"):
        print "Reading INI configuration..."
        with open(flashfile + ".ini", "r") as f:
            ip = iniparser.IniParser()
            ip.parse(f)
        configs, files = flash_cmd_generator.parse_config(ip, build_type, platform)
    elif os.path.isfile(flashfile + ".json") and not OPTIONS.unified_variants:
        print "Reading JSON configuration..."
        with open(flashfile + ".json", "r") as f:
            conf = json.loads(f.read())
        configs, files = flashxml.parse_config(conf, build_type, platform)
    elif os.path.isfile(flashfile + "_fls.json") and not OPTIONS.unified_variants:
        print "Reading JSON FLS configuration..."
        with open(flashfile + "_fls.json", "r") as f:
            conf = json.loads(f.read())
        configs, files = flashflsxml.parse_config(conf, build_type, platform)
    else:
        print "Exiting, Missing correct flashfile configuration for generating Flashfiles."
        sys.exit(1)

    with zipfile.ZipFile(args[1], "w", zipfile.ZIP_DEFLATED) as dest_zip:
        # Using "generic" instructions as reference, grab required files & insert into flashfile zip
        print "Adding required binaries..."
        for src, target in files:
            if OPTIONS.variants:
                for variant in OPTIONS.variants:
                    process_image(unpack_dir, dest_zip, src, target, variant)
            else:
                process_image(unpack_dir, dest_zip, src, target)
        # If mega flashfile is enabled, create multi-variant version of PFT instructions
        if OPTIONS.unified_variants:
            print "Adding variant specific configurations to ip..."
            vip = VariantIpGenerator(ip, configs, OPTIONS.variants, variant_files)
            vip.generate_variant_ip()
            configs, files = flash_cmd_generator.parse_config(vip.variant_ip, build_type, platform)
        # Write flash_cmd_generator parsed PFT flashing instructions to file & insert into flashfile zip
        print "Generating JSON flash configuration files..."
        for fn, data in configs:
            ifile = common.File(fn, data)
            ifile.AddToZip(dest_zip)
    print "All done."

if __name__ == '__main__':
    try:
        common.CloseInheritedPipes()
        main(sys.argv[1:])
    except common.ExternalError, e:
        print
        print "   ERROR: %s" % (e,)
        print
        sys.exit(1)
    finally:
        common.Cleanup()

