#!/usr/bin/env python
#
# Copyright (C) 2014 The Android Open Source Project
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
Creates pre-signed boot images in the destination target-files-package,
which are placed under BOOTABLE_IMAGES/. Releasetools scripts check for
these before assembling them on their own.

You should run this *after* sign_target_files_apks else the Recovery
Console ramdisk won't have production keys in it.

This script is designed to work specifically with mkbootimg-secure and
not the upstream version of 'mkbootimg'.

Usage: sign_target_files_bootimages -S <key pair> <input_target_files_zip> <output_file>

  -S  (--signpair) <path>     REQUIRED
      Path to the signing key pair, minus any file extensions (you can set those
      using --public_key_suffix/--private_key_suffix). Expects the private key
      in DER form and the public key in PEM, similar to other Android signing
      tools

  -F  (--fastboot) <path>
      Build a signed Fastboot image as well (defaults to just boot and recovery)

"""

import sys
import shutil
import zipfile
import os
import shlex

if sys.hexversion < 0x02040000:
    print >> sys.stderr, "Python 2.4 or newer is required."
    sys.exit(1)

# Android Release Tools
sys.path.append("build/tools/releasetools")
import common

sys.path.append("device/intel/build/releasetools")
import intel_common

OPTIONS = common.OPTIONS
OPTIONS.build_fastboot = False
OPTIONS.mkbootimg_key = None

def swap_key(new_key_path):
    """Examine the current 'mkbootimg_args' in the target files package
    and replace the testing key with the path to the real one"""

    mkbootimg_args_str = OPTIONS.info_dict.get("mkbootimg_args", None)
    if not mkbootimg_args_str:
        return

    e = iter(shlex.split(mkbootimg_args_str))
    newargs = []
    while True:
        try:
            i = e.next()
            newargs.append(i)
            if i == "--signkey":
                newargs.append(new_key_path + OPTIONS.private_key_suffix)
                oldkey = e.next() # discard it
        except StopIteration:
            break
    OPTIONS.info_dict["mkbootimg_args"] = " ".join(newargs)


def main(argv):

    def option_handler(o, a):
        if o in ("-S", "--signpair"):
            OPTIONS.mkbootimg_key = a
        elif o in ("-F", "--fastboot"):
            OPTIONS.build_fastboot = True
        else:
            return False
        return True

    args = common.ParseOptions(argv, __doc__,
            extra_opts="S:F",
            extra_long_opts=["signpair=", "fastboot"],
            extra_option_handler=option_handler)

    if (len(args) != 2):
        print args
        common.Usage(__doc__)
        sys.exit(1)

    if not OPTIONS.mkbootimg_key:
        print "--signpair argument missing"
        sys.exit(1)

    print "unzipping target-files..."
    OPTIONS.input_tmp, input_zip = common.UnzipTemp(args[0])
    OPTIONS.info_dict = common.LoadInfoDict(input_zip)

    misc_info = common.LoadInfoDict(input_zip)
    passwords = common.GetKeyPasswords([OPTIONS.mkbootimg_key])

    swap_key(OPTIONS.mkbootimg_key)

    print "Building destination target-files-package"
    outzip = zipfile.ZipFile(args[1], "w")
    for zi in input_zip.infolist():
        if zi.filename.startswith("BOOTABLE_IMAGES"):
            continue
        outzip.writestr(zi, input_zip.read(zi))

    for n in "boot", "recovery":
        bi = intel_common.GetBootableImage(None, "doesnt-exist.img",
                OPTIONS.input_tmp, n.upper(),
                password=passwords[OPTIONS.mkbootimg_key])
        common.ZipWriteStr(outzip, os.path.join("BOOTABLE_IMAGES", n + ".img"), bi.data)

    if OPTIONS.build_fastboot:
        bi = intel_common.GetFastbootImage(OPTIONS.input_tmp,
                password=passwords[OPTIONS.mkbootimg_key])
        common.ZipWriteStr(outzip, os.path.join("BOOTABLE_IMAGES", "fastboot.img"), bi.data)
    outzip.close()


if __name__ == '__main__':
    try:
        common.CloseInheritedPipes()
        main(sys.argv[1:])
    except common.ExternalError, e:
        print
        print "   ERROR: %s" % (e,)
        print
        sys.exit(1)

